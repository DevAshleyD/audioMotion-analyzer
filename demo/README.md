Demos
=====

[▶ **Fluid layout demo**](https://hvianna.github.io/audioMotion-analyzer/demo/fluid.html)

  + The analyzer canvas will adjust to the screen size
  + Test tones are generated by an additional frequency oscillator connected to the analyzer

[▶ **Multiple instances demo**](https://hvianna.github.io/audioMotion-analyzer/demo/multi.html)

  + Shows multiple instances of audioMotion-analyzer working simultaneously

## Code tips

Note: the demo scripts are bundled/compressed with [webpack](https://webpack.js.org/). Source code is in the project's [`src/` folder](https://github.com/hvianna/audioMotion-analyzer/tree/master/src/).

### Creating the analyzer element

This creates the audioMotion-analyzer element and sets some initial options:

```
try {
    var audioMotion = new AudioMotionAnalyzer(
        document.getElementById('container'),
        {
            source: document.getElementById('audio'),
            showFPS: true,
            minFreq: 30,
            maxFreq: 16000,
            onCanvasDraw: displayCanvasMsg
        }
    );
}
catch( err ) {
    document.getElementById('container').innerHTML = `<p>audioMotion failed with error: <em>${err}</em></p>`;
}
```

### Connecting additional audio nodes

This code fragment creates an oscillator and a gain node using audioMotion's audioContext, and then connects them to the analyzer:

```
var audioCtx = audioMotion.audioCtx,
    oscillator = audioCtx.createOscillator(),
    gainNode = audioCtx.createGain();

oscillator.frequency.setValueAtTime( 0, audioCtx.currentTime );
oscillator.connect( gainNode );
oscillator.start();
gainNode.connect( audioMotion.analyzer );
```

### onCanvasDraw callback

The demos use the onCanvasDraw callback function to draw the audioMotion logo over the analyzer canvas.
The function below is from the multi-instance demo - the calling instance object is passed as an argument to the function:

```
function displayCanvasMsg( instance ) {
    if ( ! instance.showLogo )
        return;
    var size = 20 * instance.pixelRatio;
    if ( instance.isFullscreen )
        size *= 2;
    instance.canvasCtx.font = `${size}px Orbitron,sans-serif`;
    var w = instance.canvasCtx.measureText('audioMotion').width / 2;

    instance.canvasCtx.font = `${size + instance.dataArray[ 1 ] / 16 * instance.pixelRatio}px Orbitron,sans-serif`;
    instance.canvasCtx.fillStyle = '#fff8';
    instance.canvasCtx.textAlign = 'center';
    instance.canvasCtx.fillText( 'audioMotion', instance.canvas.width - w - size * 4, size * 2 );
}
```

It reads the `dataArray` property exposed by audioMotion-analyzer and uses the amplitude of the first frequency bin to change the size of the text, making the audioMotion logo pulsate to the rhythm of the music.


## Additional notes

If you plan on allowing users to interactively toggle the [low resolution mode](https://github.com/hvianna/audioMotion-analyzer/blob/master/demo/README.md#lores-boolean), you may want to set a fixed size for the canvas via CSS, like so:

```
#container canvas {
    width: 100%;
}
```

This will prevent the canvas size from changing, when switching the low resolution mode on and off.